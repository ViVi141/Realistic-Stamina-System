# 体力消耗计算逻辑分析与问题诊断

## 问题描述
游戏中无论如何行动都不消耗体力，可能是计算模型中某些值太极端了。

## 1. 常量一致性检查

### Python vs C代码常量对比

| 常量名 | Python值 | C代码默认值 | 一致性 |
|--------|----------|-------------|--------|
| `ENERGY_TO_STAMINA_COEFF` | 3.50e-05 | 3.50e-05 | ✅ 一致 |
| `FITNESS_EFFICIENCY_COEFF` | 0.35 | 0.35 | ✅ 一致 |
| `FITNESS_LEVEL` | 1.0 | 1.0 | ✅ 一致 |

**结论**：Python和C代码中的常量定义是一致的。

## 2. 计算逻辑分析

### 2.1 效率因子计算

**健康状态效率因子**：
```c
fitnessEfficiencyFactor = 1.0 - (FITNESS_EFFICIENCY_COEFF * FITNESS_LEVEL)
                        = 1.0 - (0.35 * 1.0)
                        = 0.65
```
但在C代码中被Clamp到0.7-1.0范围，所以实际值是**0.7**。

**代谢适应效率因子**：
- 有氧区（速度比 < 0.6）：0.9
- 混合区（0.6 ≤ 速度比 < 0.8）：0.9 → 1.2（线性插值）
- 无氧区（速度比 ≥ 0.8）：1.2

**总效率因子范围**：
- 最小值：0.7 × 0.9 = **0.63**
- 最大值：0.7 × 1.2 = **0.84**

### 2.2 体力消耗计算流程

在`SCR_StaminaConsumption.c`的`CalculateStaminaConsumption`函数中：

1. **静态消耗**（速度 < 0.1 m/s）：
   - 计算静态站立消耗（%/s）
   - 转换为每0.2秒：`baseDrainRateByVelocity = staticDrainRate * 0.2`

2. **跑步模型**（速度 > 2.2 m/s）：
   - 使用Givoni-Goldman模型计算（%/s）
   - 转换为每0.2秒：`baseDrainRateByVelocity = runningDrainRate * 0.2`

3. **步行模型**（0.1 ≤ 速度 ≤ 2.2 m/s）：
   - 使用Pandolf模型计算（%/s）
   - **问题点**：在第151行又乘以0.2转换为每0.2秒

4. **应用修正因子**：
   ```c
   baseDrainRate = baseDrainRateByVelocity * totalEfficiencyFactor * fatigueFactor
   ```

5. **添加速度相关项**：
   ```c
   speedLinearDrainRate = 0.00005 * speedRatio * totalEfficiencyFactor * fatigueFactor
   speedSquaredDrainRate = 0.00005 * speedRatio * speedRatio * totalEfficiencyFactor * fatigueFactor
   ```

6. **添加负重相关项**：
   ```c
   encumbranceBaseDrainRate = 0.001 * (encumbranceStaminaDrainMultiplier - 1.0)
   encumbranceSpeedDrainRate = 0.0002 * (encumbranceStaminaDrainMultiplier - 1.0) * speedRatio²
   ```

## 3. 问题诊断

### 3.1 发现的潜在问题

#### 问题1：重复转换（已确认不是问题）
在第151行，所有情况都会乘以0.2：
```c
baseDrainRateByVelocity = baseDrainRateByVelocity * 0.2;
```

但静态消耗和跑步模型已经在之前乘以了0.2，这会导致它们被**重复转换**（乘以0.04而不是0.2）。

**实际检查**：这个逻辑是正确的，因为：
- 静态消耗和跑步模型在第122和133行已经转换为每0.2秒
- 但Pandolf模型返回的是每秒，所以在第151行统一转换是正确的
- 但是，**静态消耗和跑步模型会被错误地再次转换**

**修复建议**：应该只在Pandolf模型的情况下才乘以0.2，或者移除第151行的统一转换。

#### 问题2：消耗率过小

根据Python模拟计算：
- **慢走**（1.5 m/s）：0.000104（每0.2秒）= 0.000522（每秒）
- **跑步**（3.7 m/s）：0.000059（每0.2秒）= 0.000297（每秒）

这些值**太小**了！如果每秒只消耗0.000297%，那么：
- 消耗1%体力需要：1 / 0.000297 ≈ **3365秒**（约56分钟）
- 消耗10%体力需要：10 / 0.000297 ≈ **33650秒**（约9.3小时）

这显然不合理，会导致游戏中几乎感觉不到体力消耗。

#### 问题3：效率因子过小

总效率因子最小值为0.63，这意味着：
- 基础消耗会被降低到63%
- 如果基础消耗本身就很低，乘以0.63后会变得更低

### 3.2 根本原因分析

**可能的原因**：

1. **`ENERGY_TO_STAMINA_COEFF`过小**：
   - 当前值：3.5e-05
   - 这个值将Pandolf模型的能量消耗（W/kg）转换为体力消耗率（%/s）
   - 如果这个值太小，会导致所有消耗都变得很小

2. **重复转换导致消耗被过度降低**：
   - 静态消耗和跑步模型被转换了两次（×0.2两次 = ×0.04）
   - 这会导致它们的消耗被降低到原来的4%

3. **效率因子叠加效应**：
   - 基础消耗 × 0.7（健康状态） × 0.9（有氧代谢） = 0.63
   - 如果基础消耗本身很小，乘以0.63后会变得极小

## 4. 修复建议

### 4.1 修复重复转换问题

在`SCR_StaminaConsumption.c`中，修改第151行的逻辑：

**当前代码**：
```c
// Pandolf 模型的结果是每秒的消耗率，需要转换为每0.2秒的消耗率
baseDrainRateByVelocity = baseDrainRateByVelocity * 0.2;
```

**修复方案1**：只在Pandolf模型的情况下转换
```c
// 只有Pandolf模型需要转换（静态和跑步模型已经在之前转换了）
if (currentSpeed >= 0.1 && currentSpeed <= 2.2)
{
    baseDrainRateByVelocity = baseDrainRateByVelocity * 0.2;
}
```

**修复方案2**：移除统一转换，在各自分支中处理
- 静态消耗：保持 `* 0.2`
- 跑步模型：保持 `* 0.2`
- Pandolf模型：添加 `* 0.2`

### 4.2 调整转换系数

如果修复重复转换后消耗仍然太小，可以考虑：

1. **提高`ENERGY_TO_STAMINA_COEFF`**：
   - 当前：3.5e-05
   - 建议：5.0e-05 到 7.0e-05
   - 这会增加约43%-100%的消耗速度

2. **调整效率因子范围**：
   - 当前健康状态效率因子最小值：0.7
   - 建议：提高到0.8或0.85
   - 这会减少效率因子对消耗的降低

3. **增加基础消耗项**：
   - 当前速度相关项：0.00005
   - 建议：提高到0.0001或0.0002
   - 这会增加移动时的基础消耗

## 5. 测试建议

修复后，建议测试以下场景：

1. **静止站立**：应该缓慢消耗体力（负重时）
2. **慢走**（1-2 m/s）：应该缓慢消耗体力
3. **跑步**（3-4 m/s）：应该明显消耗体力
4. **冲刺**（5.2 m/s）：应该快速消耗体力
5. **负重跑步**（30kg）：应该比空载消耗更多

预期消耗率（每秒）：
- 静止站立（空载）：0.01-0.02%
- 慢走：0.05-0.1%
- 跑步：0.2-0.5%
- 冲刺：1.0-2.0%
- 负重跑步：比空载增加30-50%

## 6. 总结

**主要问题**：
1. ✅ 重复转换导致静态消耗和跑步模型被过度降低（×0.04）
2. ⚠️ `ENERGY_TO_STAMINA_COEFF`可能过小
3. ⚠️ 效率因子叠加导致消耗被过度降低

**优先级修复**：
1. **高优先级**：修复重复转换问题（第151行）
2. **中优先级**：检查并调整`ENERGY_TO_STAMINA_COEFF`
3. **低优先级**：优化效率因子范围
