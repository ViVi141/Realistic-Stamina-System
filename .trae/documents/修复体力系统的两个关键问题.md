# 修复体力系统的两个关键问题

## 1. 位置差分测速的“时间步长”硬编码风险

**问题**：在 `SCR_StaminaUpdateCoordinator.c` 中的 `CalculateCurrentSpeed` 函数，`dtSeconds` 是由 `SPEED_UPDATE_INTERVAL_MS * 0.001` 传进去的固定值。如果服务器或客户端出现掉帧，实际两帧之间的时间可能远大于设定的固定值，导致计算出的速度不准确。

**修复方案**：
- 在 `PlayerBase.c` 中添加一个成员变量 `m_fLastSpeedUpdateTime` 来存储上次速度更新的时间戳
- 在每次调用 `CalculateCurrentSpeed` 函数时，使用当前时间戳减去上次时间戳来计算真实的 `dt`
- 更新 `m_fLastSpeedUpdateTime` 为当前时间戳
- 这样可以确保即使在掉帧情况下，也能使用真实的时间差来计算速度

## 2. 高频监听器的内存/性能回收

**问题**：在 `SCR_StaminaOverride.c` 中的 `StartStaminaMonitor` 使用了 `GetGame().GetCallqueue().CallLater(MonitorStamina, 16, false)`，这是一个 60Hz 的死循环。如果玩家断开连接、角色实体被销毁或更换，这个循环可能仍在 CallLater 队列中尝试访问已经失效的 `m_pStaminaComponent`。

**修复方案**：
- 在 `SCR_StaminaOverride.c` 中重写 `OnDelete` 方法，显式调用 `StopStaminaMonitor()`
- 确保当角色实体被销毁时，CallLater 队列中的监听器被正确停止
- 这样可以避免访问已经失效的组件，减少内存泄漏和性能问题

## 修复步骤

1. 修改 `PlayerBase.c`：
   - 添加成员变量 `m_fLastSpeedUpdateTime`
   - 在 `PlayerBase` 构造函数或初始化函数中初始化 `m_fLastSpeedUpdateTime`
   - 修改速度计算逻辑，使用真实时间差计算 `dt`

2. 修改 `SCR_StaminaOverride.c`：
   - 重写 `OnDelete` 方法，调用 `StopStaminaMonitor()`
   - 确保 `StopStaminaMonitor()` 能正确停止 CallLater 循环

## 预期效果

1. 速度计算更加准确，即使在掉帧情况下也能正确计算速度，避免了体力消耗异常和物理限速问题
2. 资源管理更加完善，避免了内存泄漏和无效的 CallLater 调用，提高了系统稳定性

## 测试建议

1. 测试掉帧情况下的速度计算准确性
2. 测试角色切换或断开连接时，CallLater 循环是否正确停止
3. 测试长时间游戏后的内存使用情况，确保没有内存泄漏