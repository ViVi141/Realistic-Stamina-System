## 修复配置管理逻辑计划

### 问题分析
当前配置管理存在逻辑缺陷：当JSON文件已存在且包含预设块时，`InitPresets()` 因为对象不为null就不再初始化，导致模组更新了更优的Optuna参数后，玩家的JSON里还留着旧版本的预设数值。

### 修复目标
- 系统预设（Elite/Standard/Tactical）永远使用代码中最新的Optuna参数
- 用户自定义（Custom）预设完全尊重JSON现有数值，不进行覆盖
- 确保配置文件与代码中的最新预设保持同步

### 修复方案

#### 1. 修改 `SCR_RSS_Settings.c`
重构 `InitPresets` 方法，将其分为"强制更新系统预设"和"初始化Custom"两部分：

- 添加 `forceRefreshSystemPresets` 参数
- 确保所有预设对象都已实例化
- 仅在 `Custom` 预设不存在时初始化默认值
- 如果 `forceRefreshSystemPresets` 为 `true`，强制更新所有系统预设

#### 2. 修改 `SCR_RSS_ConfigManager.c`
更新 `Load()` 方法，根据当前选中的预设决定是否强制刷新：

- 检查 `m_sSelectedPreset` 字段
- 如果不是 `Custom`：
  - 调用 `InitPresets(true)` 强制刷新系统预设
  - 立即调用 `Save()` 同步更新到JSON文件
- 如果是 `Custom`：
  - 调用 `InitPresets(false)` 仅初始化缺失的字段
  - 保留用户自定义的所有数值

### 预期效果
- 场景A（玩家使用EliteStandard）：模组更新后，玩家的JSON文件会自动更新为最新的Optuna参数
- 场景B（玩家使用Custom）：玩家手动修改的参数会被完整保留，不受模组更新影响

### 代码修改点
1. **SCR_RSS_Settings.c**：重构 `InitPresets` 方法
2. **SCR_RSS_ConfigManager.c**：修改 `Load` 方法，添加预设检查和强制刷新逻辑

### 测试建议
- 测试场景A：选择非Custom预设，更新模组后检查JSON文件是否被更新
- 测试场景B：选择Custom预设，修改参数后更新模组，检查参数是否被保留
- 测试场景C：首次安装模组，检查默认配置是否正确生成

这个修复确保了系统预设永远是最优解，同时尊重用户的自定义配置，解决了当前配置管理的核心问题。