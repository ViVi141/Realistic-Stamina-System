# 地形密度到地形系数映射表（基于实际测试）

本文档记录了基于 Arma Reforger 实际测试的地面材质密度值，以及对应的地形系数（Terrain Factor）。

---

## 📊 测试数据

### 实际测试的材质密度值

| 材质类型 | 密度值 | 地形系数 (η) | 说明 |
|---------|--------|-------------|------|
| **沥青路面** | 2.24 | 1.0 | 基准值（铺装路面） |
| **混凝土** | 2.3 | 1.0 | 铺装路面（基准） |
| **室内地板** | 1.13 | 1.0 | 室内平整地面（基准） |
| **木箱** | 0.65 | 1.0 | 人工结构（视为基准） |
| **土质** | 1.33 | 1.1 | 碎石路、硬质土路 |
| **草地** | 1.2 | 1.2 | 高草丛、荒野 |
| **床垫** | 1.55 | 1.3 | 软质地面（轻微增加消耗） |
| **海岸鹅卵石** | 1.6 | 1.4 | 不平整路面（中等增加） |
| **铁棚** | 2.7 | 1.5 | 金属表面（重度灌木丛级别） |
| **陶片屋顶** | 2.94 | 1.8 | 瓦片表面（软沙地级别） |

---

## 🔍 分析

### 密度与地形系数的关系

**重要发现**：
- **密度值 ≠ 地形系数**
- 密度是物理属性（材质硬度/密度）
- 地形系数是能量消耗倍数（影响行走消耗）

**映射规律**：
1. **低密度（0.6-1.3）**：通常对应基准或轻微增加（η = 1.0-1.2）
   - 软质/多孔材质（木箱、地板）
   
2. **中密度（1.3-1.6）**：对应轻度到中度增加（η = 1.1-1.4）
   - 自然路面（土质、草地、鹅卵石）
   
3. **高密度（2.0-3.0）**：对应中度到重度增加（η = 1.5-1.8）
   - 硬质但可能不平整的材质（铁棚、陶片）

**异常情况**：
- **沥青路面（2.24）**：虽然密度高，但由于表面平整，应为基准值 η = 1.0
- **混凝土（2.3）**：同理，平整表面应为基准值 η = 1.0
- **铁棚（2.7）**：高密度但不平整，增加消耗 η = 1.5

---

## 📐 映射算法

### 方案一：基于实际测试数据的插值映射（推荐）⭐

**原理**：
- 使用已知测试数据点进行插值
- 在已知点之间使用线性插值，实现平滑过渡
- 未知密度值通过插值计算得到地形系数

**测试数据点**（密度 → 地形系数）：
```
(0.65, 1.0)  - 木箱
(1.13, 1.0)  - 室内地板
(1.2,  1.2)  - 草地
(1.33, 1.1)  - 土质
(1.55, 1.3)  - 床垫
(1.6,  1.4)  - 海岸鹅卵石
(2.24, 1.0)  - 沥青路面
(2.3,  1.0)  - 混凝土
(2.7,  1.5)  - 铁棚
(2.94, 1.8)  - 陶片屋顶
```

**实现**：
```enforce
static float GetTerrainFactorFromDensity(float density)
{
    if (density <= 0.0)
        return 1.0; // 默认值
    
    // 特殊情况：高密度平整表面（沥青、混凝土）
    // 这些材质密度高但表面平整，应为基准值
    if (density >= 2.2 && density <= 2.4)
        return 1.0; // 沥青(2.24)、混凝土(2.3) → 1.0
    
    // 特殊情况：低密度平整表面（木箱、室内地板）
    if (density <= 0.7)
        return 1.0; // 木箱(0.65) → 1.0
    
    // 已知数据点（按密度排序）
    // 密度点：[0.65, 1.13, 1.2, 1.33, 1.55, 1.6, 2.24, 2.3, 2.7, 2.94]
    // 系数点：[1.0,  1.0,  1.2, 1.1,  1.3,  1.4, 1.0,  1.0, 1.5, 1.8]
    
    // 分段插值：根据密度值落在哪个区间进行插值
    
    // 区间 1: 0.7 < density <= 1.2
    // 点：室内地板(1.13, 1.0) → 草地(1.2, 1.2)
    if (density <= 1.2)
    {
        if (density <= 1.13)
            return 1.0; // 室内地板区间
        // 插值：(1.13, 1.0) → (1.2, 1.2)
        float t = (density - 1.13) / (1.2 - 1.13);
        return 1.0 + t * 0.2; // 1.0 → 1.2
    }
    
    // 区间 2: 1.2 < density <= 1.33
    // 点：草地(1.2, 1.2) → 土质(1.33, 1.1)
    if (density <= 1.33)
    {
        float t = (density - 1.2) / (1.33 - 1.2);
        return 1.2 - t * 0.1; // 1.2 → 1.1（下降）
    }
    
    // 区间 3: 1.33 < density <= 1.6
    // 点：土质(1.33, 1.1) → 床垫(1.55, 1.3) → 海岸鹅卵石(1.6, 1.4)
    if (density <= 1.55)
    {
        // 子区间：土质 → 床垫
        float t = (density - 1.33) / (1.55 - 1.33);
        return 1.1 + t * 0.2; // 1.1 → 1.3
    }
    else if (density <= 1.6)
    {
        // 子区间：床垫 → 海岸鹅卵石
        float t = (density - 1.55) / (1.6 - 1.55);
        return 1.3 + t * 0.1; // 1.3 → 1.4
    }
    
    // 区间 4: 1.6 < density < 2.2（跳过沥青、混凝土的特殊处理区间）
    // 点：海岸鹅卵石(1.6, 1.4) → 沥青(2.24, 1.0)
    // 注意：这是一个下降区间，但在 2.2-2.4 有特殊处理
    if (density < 2.2)
    {
        // 线性下降：海岸鹅卵石(1.6, 1.4) → 假设在 2.2 处为某个值
        // 由于缺乏中间数据点，这里假设平滑过渡到 1.0
        float t = (density - 1.6) / (2.2 - 1.6);
        return 1.4 - t * 0.4; // 1.4 → 1.0（平滑过渡）
    }
    
    // 区间 5: 2.4 < density <= 2.7
    // 点：混凝土(2.3, 1.0) → 铁棚(2.7, 1.5)
    // 注意：2.2-2.4 区间已特殊处理为 1.0
    if (density <= 2.7)
    {
        float t = (density - 2.4) / (2.7 - 2.4);
        return 1.0 + t * 0.5; // 1.0 → 1.5
    }
    
    // 区间 6: 2.7 < density
    // 点：铁棚(2.7, 1.5) → 陶片屋顶(2.94, 1.8)
    if (density <= 2.94)
    {
        float t = (density - 2.7) / (2.94 - 2.7);
        return 1.5 + t * 0.3; // 1.5 → 1.8
    }
    
    // 超出已知范围：外推（使用最后一个区间的斜率）
    // 陶片屋顶(2.94, 1.8) → 外推
    float t = (density - 2.94) / (3.0 - 2.94); // 假设最大为 3.0
    return Math.Clamp(1.8 + t * 0.2, 1.8, 2.0); // 外推到 2.0（软沙地/深雪级别）
}
```

**优缺点**：
- ✅ **优点**：基于实际测试数据，精确度高
- ✅ **优点**：插值实现平滑过渡，避免突变
- ✅ **优点**：可以处理未知密度值（通过插值计算）
- ⚠️ **注意**：需要维护数据点列表，新增材质需要更新插值区间

### 方案二：基于密度区间的分段映射（备选）

```enforce
static float GetTerrainFactorFromDensity(float density)
{
    // 密度值范围：0.5 - 3.0
    
    // 低密度：基准值或轻微增加（软质/多孔材质）
    if (density <= 0.7)      return 1.0;  // 木箱等（0.65）
    if (density <= 1.15)     return 1.0;  // 室内地板等（1.13）
    if (density <= 1.25)     return 1.2;  // 草地（1.2）
    if (density <= 1.4)      return 1.1;  // 土质（1.33）
    
    // 中密度：轻度到中度增加（自然路面）
    if (density <= 1.6)      return 1.4;  // 海岸鹅卵石（1.6）
    if (density <= 1.65)     return 1.3;  // 床垫（1.55）
    
    // 高密度：需要判断表面是否平整
    // 平整表面（沥青、混凝土）：基准值
    if (density >= 2.2 && density <= 2.4)  return 1.0;  // 沥青（2.24）、混凝土（2.3）
    
    // 高密度且不平整：中度到重度增加
    if (density <= 2.8)      return 1.5;  // 铁棚（2.7）
    if (density <= 3.0)      return 1.8;  // 陶片屋顶（2.94）
    
    // 默认值
    return 1.0;
}
```

### 方案二：基于密度值的线性/非线性映射

```enforce
static float GetTerrainFactorFromDensity(float density)
{
    // 特殊情况：平整的高密度材质（沥青、混凝土）
    if (density >= 2.2 && density <= 2.4)
        return 1.0; // 基准值
    
    // 特殊情况：低密度软质材质（木箱）
    if (density <= 0.7)
        return 1.0; // 基准值
    
    // 非线性映射：密度值 → 地形系数
    // 使用分段线性插值
    if (density <= 1.2)
    {
        // 密度 1.13 (地板) → 1.0，密度 1.2 (草地) → 1.2
        float t = (density - 1.13) / (1.2 - 1.13);
        return 1.0 + t * 0.2; // 1.0 → 1.2
    }
    else if (density <= 1.4)
    {
        // 密度 1.2 (草地) → 1.2，密度 1.33 (土质) → 1.1
        float t = (density - 1.2) / (1.4 - 1.2);
        return 1.2 - t * 0.1; // 1.2 → 1.1（土质比草地更硬，但更平整）
    }
    else if (density <= 1.65)
    {
        // 密度 1.4 → 1.1，密度 1.6 (鹅卵石) → 1.4
        float t = (density - 1.4) / (1.65 - 1.4);
        return 1.1 + t * 0.3; // 1.1 → 1.4
    }
    else if (density <= 2.2)
    {
        // 密度 1.65 → 1.4，密度 2.2 → 1.5（铁棚等高密度材质）
        float t = (density - 1.65) / (2.2 - 1.65);
        return 1.4 + t * 0.1; // 1.4 → 1.5
    }
    else if (density <= 2.8)
    {
        // 密度 2.7 (铁棚) → 1.5
        return 1.5;
    }
    else
    {
        // 密度 2.94 (陶片) → 1.8
        return 1.8;
    }
}
```

---

## 🎯 推荐方案

**推荐使用方案一（分段映射）**，原因：
1. **简单直观**：基于实际测试数据直接映射
2. **易于维护**：新增材质只需添加条件分支
3. **精确控制**：可以针对特定密度值设置精确系数
4. **性能更好**：避免了复杂的插值计算

---

## 📝 代码实现建议

### 在 `SCR_RealisticStaminaSystem.c` 中实现

```enforce
class RealisticStaminaSpeedSystem
{
    // ... 现有代码 ...
    
    // 根据密度值获取地形系数（基于实际测试数据）
    static float GetTerrainFactorFromDensity(float density)
    {
        if (density <= 0.0)
            return TERRAIN_FACTOR_PAVED; // 默认值
        
        // 低密度：基准值或轻微增加
        if (density <= 0.7)      return TERRAIN_FACTOR_PAVED;      // 木箱：0.65 → 1.0
        if (density <= 1.15)     return TERRAIN_FACTOR_PAVED;      // 室内地板：1.13 → 1.0
        if (density <= 1.25)     return TERRAIN_FACTOR_GRASS;      // 草地：1.2 → 1.2
        if (density <= 1.4)      return TERRAIN_FACTOR_DIRT;       // 土质：1.33 → 1.1
        
        // 中密度：轻度到中度增加
        if (density <= 1.6)      return 1.4;                       // 海岸鹅卵石：1.6 → 1.4
        if (density <= 1.65)     return 1.3;                       // 床垫：1.55 → 1.3
        
        // 高密度：平整表面为基准值，不平整表面增加消耗
        if (density >= 2.2 && density <= 2.4)
            return TERRAIN_FACTOR_PAVED;      // 沥青(2.24)、混凝土(2.3) → 1.0
        
        // 高密度且不平整
        if (density <= 2.8)      return TERRAIN_FACTOR_BRUSH;      // 铁棚：2.7 → 1.5
        if (density <= 3.0)      return TERRAIN_FACTOR_SAND;       // 陶片屋顶：2.94 → 1.8
        
        // 默认值
        return TERRAIN_FACTOR_PAVED;
    }
}
```

---

## 🔬 未来测试建议

### 需要测试的材质

1. **沙地**：预期密度 1.5-2.0，地形系数 η = 1.8
2. **雪地**：预期密度 0.8-1.2，地形系数 η = 2.1
3. **泥地**：预期密度 1.8-2.2，地形系数 η = 2.5
4. **碎石路**：预期密度 1.8-2.2，地形系数 η = 1.1
5. **灌木丛**：预期密度 0.5-1.0，地形系数 η = 1.5
6. **湿地**：预期密度 1.5-2.0，地形系数 η = 1.5

---

## 📚 参考

- **测试日期**: 2024-12-19
- **测试环境**: Arma Reforger 游戏内实际测试
- **测试方法**: 使用 `BallisticInfo.GetDensity()` API 获取密度值
- **测试人员**: ViVi141

---

**最后更新**: 2024-12-19
